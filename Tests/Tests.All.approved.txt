Full name: Tests, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
Image runtime version: v4.0.30319
abstract class Abstract
{
}
[Flags]
enum BigFlags : int
{
    V0 = 1
    V1 = 16
    V2 = 256
    V3 = 4096
}
enum Byte : byte
{
}
enum Default : int
{
}
class DeriveAndImpl : Impl, IUsual
{
    constructor();
}
class Derived : Abstract
{
    constructor();
}
class DeriveLong : Generic<List<List<List<List<List<List<List<List<int>>>>>>>>>
{
    constructor();
}
[Flags]
enum Flags : int
{
}
virtual class Generic<T>
{
    constructor();
}
struct GenericImplGeneric<T> : ValueType, IGeneric<T>
{
}
class GenericWithConstraint<T>
where T : IUsual
{
    constructor();
}
interface ICovariance<T>
{
}
interface IDerived : IUsual
{
}
interface IGeneric<T>
{
}
interface IGenericWithConstraint<T>
where T : IUsual
{
}
interface IIndirectDerive : IDerived, IUsual
{
    virtual abstract void F();
}
interface IM
{
    int P1 { get; }
    int P2 { get; set; }
    int P3 { set; }
    virtual abstract void M1();
    virtual abstract void M2(int a1);
    virtual abstract void M3(int a1, int a2);
    virtual abstract int M4();
    virtual abstract int M5<T>();
    virtual abstract int M6<T : IUsual>();
}
virtual class Impl : IUsual
{
    constructor();
}
class ImplAndDeriveLong : Generic<List<List<List<List<List<List<List<List<int>>>>>>>>>, IGeneric<List<List<List<List<List<List<List<List<int>>>>>>>>>
{
    constructor();
}
struct ImplGeneric : ValueType, IGeneric<int>
{
}
class ImplLong : IGeneric<List<List<List<List<List<List<List<List<int>>>>>>>>>
{
    constructor();
}
interface IMultiDerived : IDerived, IUsual
{
}
class IndirectImpl : Impl, IUsual
{
    constructor();
}
struct InheritConstraint<T> : ValueType, IGenericWithConstraint<T>
where T : IUsual
{
}
interface IUsual
{
}
interface IVariance<T>
{
}
abstract class M
{
    int F1;
    readonly int F2;
    static int F4;
    const int X1;
    const string X2;
    const string X3;
    const double X4;
    const double X5;
    string Item { get; set; }
    string Item { get; set; }
    string Item { get; set; }
    string Item { set; }
    string Item { set; }
    string Item { get; }
    int P1 { get; }
    int P11 { get; }
    int P12 { get; }
    int P13 { get; }
    int P2 { get; set; }
    int P3 { get; }
    int P4 { get; }
    int P5 { set; }
    int P6 { set; }
    constructor(int a1);
    virtual abstract void M1();
    virtual abstract void M17(int a1, out int a2);
    void M18();
    virtual abstract int M19<T>();
    virtual abstract void M2(int a1);
    virtual abstract int M20<T : ValueType>();
    virtual abstract int M21<T>();
    virtual abstract int M22<
        TLongLongLongLongLongArg1
        TLongLongLongLongLongArg2
        TLongLongLongLongLongArg3
    >();
    virtual abstract int M23<
        TLongLongLongLongLongArg1
        TLongLongLongLongLongArg2
        TLongLongLongLongLongArg3
    >(
        TLongLongLongLongLongArg1 a1
        TLongLongLongLongLongArg2 a2
        TLongLongLongLongLongArg3 a3
    );
    virtual abstract int M24(
        Dictionary<string, List<Uri>> anotherLongName
        string longLongLongName
        string notLongEnough
    );
    virtual abstract int M25(string arg = );
    virtual abstract int M26(string[] arg);
    virtual abstract int M27<
        TLongLongLongLongLongArg1 : ICloneable
        TLongLongLongLongLongArg2
        TLongLongLongLongLongArg3
    >();
    virtual abstract void M28(
        int longLongLongLongLongLongLongLongArg1
        out int longLongLongLongLongLongLongLongArg2
    );
    virtual abstract int M29(
        int a1
        int a2
        string longLongLongLongLongLongLongLongArg1 = 
    );
    virtual abstract void M3(int a1, int a2);
    virtual abstract int M4();
    virtual abstract int M5<T>();
    virtual abstract int M6<T : IUsual>();
    virtual void M7();
    void M8();
    event EventHandler E1;
    event EventHandler<NetworkAvailabilityEventArgs> E2;
    event Action E3;
}
abstract class MM
{
}
virtual class NonSealed
{
    constructor();
}
class Sealed
{
    constructor();
}
enum Seq : int
{
    V0 = 0
    V1 = 1
    V2 = 2
}
enum Short : short
{
}
abstract class Static
{
}
struct Struct : ValueType
{
}
struct StructContainer : ValueType, IDerived, IIndirectDerive, IUsual
{
    int F1;
    readonly int F2;
    static int F4;
    const int X1;
    string Item { get; set; }
    string Item { set; }
    string Item { get; }
    string Item { set; }
    string Item { get; }
    int P1 { get; }
    int P13 { get; }
    int P2 { get; set; }
    int P4 { get; }
    int P5 { set; }
    constructor(int a1);
    virtual void F();
    void M1();
    void M18();
    void M2(int a1);
    void M3(int a1, int a2);
    int M4();
    int M5<T>();
    int M6<T : IUsual>();
    virtual string ToString();
}
struct StructImpl : ValueType, IUsual
{
}
class Tests
{
    constructor();
    void All();
}
enum ULong : ulong
{
}
