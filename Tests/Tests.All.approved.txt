Full name: Tests, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
Image runtime version: v4.0.30319
abstract class Abstract
{
}
[Flags]
enum BigFlags : int
{
    V0 = 1
    V1 = 16
    V2 = 256
    V3 = 4096
}
enum Byte : byte
{
}
enum Default : int
{
}
class DeriveAndImpl : Impl, IUsual
{
    constructor();
}
class Derived : Abstract
{
    constructor();
}
class DeriveLong : Generic<List<List<List<List<List<List<List<List<int>>>>>>>>>
{
    constructor();
}
[Flags]
enum Flags : int
{
}
virtual class Generic<T>
{
    constructor();
}
delegate T1 GenericArgsAndReturnValue<out T1, in T2>(T2 a1 = default(T2));
delegate void GenericConstraints<T>()
    where T : Abstract, new();
struct GenericImplGeneric<T> : IGeneric<T>
{
}
class GenericWithConstraint<T>
    where T : IUsual
{
    constructor();
}
interface IContravariant<in T>
{
}
interface ICovariant<out T>
{
}
interface IDerived : IUsual
{
}
interface IGeneric<T>
{
}
interface IGenericWithConstraint<T>
    where T : IUsual
{
}
interface IIndirectDerive : IDerived, IUsual
{
    void F();
}
interface IM
{
    int P1 { get; }
    int P2 { get; set; }
    int P3 { set; }
    void M1();
    void M2(int a1);
    void M3(int a1, int a2);
    int M4();
    int M5<T>();
    int M6<T>()
        where T : IUsual;
}
virtual class Impl : IUsual
{
    constructor();
}
class ImplAndDeriveLong : Generic<List<List<List<List<List<List<List<List<int>>>>>>>>>, IGeneric<List<List<List<List<List<List<List<List<int>>>>>>>>>
{
    constructor();
}
struct ImplGeneric : IGeneric<int>
{
}
class ImplLong : IGeneric<List<List<List<List<List<List<List<List<int>>>>>>>>>
{
    constructor();
}
interface IMultiDerived : IDerived, IGeneric<int>, IUsual
{
}
class IndirectImpl : Impl, IUsual
{
    constructor();
}
struct InheritConstraint<T> : IGenericWithConstraint<T>
    where T : IUsual
{
}
interface IUsual
{
}
abstract class M
{
    int F1;
    readonly int F2;
    int F3;
    static int F4;
    const int X1;
    const string X2;
    const string X3;
    const double X4;
    const double X5;
    string this[int index] { get; set; }
    protected string this[string index] { get; set; }
    string this[double index] { get; set; }
    string this[double index, int arg2] { get; set; }
    string this[byte i] { protected get; set; }
    string this[short i] { set; }
    string this[ushort i] { get; }
    int P1 { get; }
    int P10 { protected get; }
    int P11 { get; }
    int P12 { get; }
    int P13 { get; }
    int P2 { get; set; }
    int P3 { get; protected set; }
    int P4 { get; }
    int P5 { set; }
    int P6 { protected get; set; }
    protected int P7 { get; }
    protected int P8 { get; set; }
    int P9 { protected set; }
    constructor(int a1);
    abstract void M1();
    abstract void M17(ref int a1, out int a2);
    void M18();
    abstract int M19<T>();
    abstract void M2(int a1);
    abstract int M20<T>()
        where T : struct;
    abstract int M21<T>();
    abstract int M22<TLongLongLongLongLongArg1, TLongLongLongLongLongArg2, TLongLongLongLongLongArg3>();
    abstract int M23<TLongLongLongLongLongArg1, TLongLongLongLongLongArg2, TLongLongLongLongLongArg3>(TLongLongLongLongLongArg1 a1, TLongLongLongLongLongArg2 a2, TLongLongLongLongLongArg3 a3);
    abstract int M24(Dictionary<string, List<Uri>> anotherLongName, string longLongLongName, string notLongEnough);
    abstract int M25(string arg = default(string));
    abstract int M26(params string[] arg);
    abstract int M27<TLongLongLongLongLongArg1, TLongLongLongLongLongArg2, TLongLongLongLongLongArg3>()
        where TLongLongLongLongLongArg1 : ICloneable;
    abstract void M28(ref int longLongLongLongLongLongLongLongArg1, out int longLongLongLongLongLongLongLongArg2);
    abstract int M28<T>()
        where T : class, IGeneric<int>, new();
    abstract int M29(int a1, int a2, string longLongLongLongLongLongLongLongArg1 = default(string));
    abstract void M3(int a1, int a2);
    abstract int M4();
    abstract int M5<T>();
    abstract int M6<T>()
        where T : IUsual;
    virtual void M7();
    void M8();
    event EventHandler E1;
    event EventHandler<NetworkAvailabilityEventArgs> E2;
    event Action E3;
}
class M+NestedPublic
{
    constructor();
}
abstract class MM : M
{
    int F1;
    readonly int F2;
    int F3;
    string this[double index] { get; set; }
    int P11 { get; }
    int P12 { get; }
    virtual void M1();
    event EventHandler E1;
    event EventHandler<NetworkAvailabilityEventArgs> E2;
    event Action E3;
}
virtual class NonSealed
{
    constructor();
}
delegate void OutAndRefAndParams(out int a1, ref string a2, params object[] a3);
delegate int ReturnValueAndArg(int a1, int opt = 0);
delegate void SampleDelegate();
class Sealed
{
    constructor();
}
enum Seq : int
{
    V0 = 0
    V1 = 1
    V2 = 2
}
enum Short : short
{
}
abstract class Static
{
}
struct Struct
{
}
struct StructContainer : IDerived, IIndirectDerive, IUsual
{
    int F1;
    readonly int F2;
    static int F4;
    const int X1;
    string this[int index] { get; set; }
    string this[float index] { set; }
    string this[sbyte index] { get; }
    string this[double index] { set; }
    string this[byte index] { get; }
    int P1 { get; }
    int P13 { get; }
    int P2 { get; set; }
    int P4 { get; }
    int P5 { set; }
    constructor(int a1);
    virtual void F();
    void M1();
    void M18();
    void M2(int a1);
    void M3(int a1, int a2);
    int M4();
    int M5<T>();
    int M6<T>()
        where T : IUsual;
    virtual string ToString();
}
struct StructImpl : IUsual
{
}
class Tests
{
    constructor();
    void All();
}
enum ULong : ulong
{
}
